--- Lab-8/3081-297318//297318_buggy.c	2023-11-27 20:53:21.292461003 +0200
+++ Lab-8/3081-297318//Main.c	2023-11-27 20:53:21.292461003 +0200
@@ -1,135 +1,112 @@
-/*numPass=7, numTotal=8
-Verdict:ACCEPTED, Visibility:1, Input:"3 4
+/*
+Up to 20% marks will be allotted for good programming practice. These include
+- Comments: for nontrivial code
+- Indentation: align your code properly
+- Function use and modular programming
+- Do not include anything in the header other than what is already given in the
+template.
+--------------------------------------------------------------------------------------------------------------
+
+We say that a matrix is good if there is a sub-matrix which is an identity
+matrix.  If a matrix is not good, then I say its goodness is 0. However, if it
+is good, we define goodness to be the dimension of largest identity sub-matrix
+of the given matrix (i.e. if identity sub-matrix is n x n, then the goodness is
+n). For example,
+
 0 1 1 0
 1 0 0 1
-1 0 2 3", ExpOutput:"2 1 3
-", Output:"2 1 3"
-Verdict:ACCEPTED, Visibility:1, Input:"5 5
-1 0 0 0 0
-0 1 0 0 0
-0 0 1 0 0
-0 0 0 1 0
-0 0 0 0 1", ExpOutput:"5 1 1
-", Output:"5 1 1"
-Verdict:ACCEPTED, Visibility:1, Input:"2 2
-0 2
-3 4", ExpOutput:"0 -1 -1
-", Output:"0 -1 -1"
-Verdict:ACCEPTED, Visibility:1, Input:"1 1
-0", ExpOutput:"0 -1 -1
-", Output:"0 -1 -1"
-Verdict:ACCEPTED, Visibility:1, Input:"5 5
-3 2 3 4 5
-1 2 3 4 5
-6 7 8 9 10
-11 23 5 5 5
--1 2 3 4 5", ExpOutput:"1 2 1
-", Output:"1 2 1"
-Verdict:ACCEPTED, Visibility:0, Input:"5 2
+1 0 2 3
+
+This matrix is good since
 1 0
 0 1
-0 0
-1 0
-0 1", ExpOutput:"2 1 1
-", Output:"2 1 1"
-Verdict:WRONG_ANSWER, Visibility:0, Input:"1 1
-1", ExpOutput:"1 1 1
-", Output:"0 -1 -1"
-Verdict:ACCEPTED, Visibility:0, Input:"10 10
--1 -1 -1 -1 -1 -1 -1 -1 -1 -1
--1 -1 -1 -1 -1 -1 -1 -1 -1 -1
--1 -1 -1 -1 -1 -1 -1 -1 -1 -1
--1 -1 -1 -1 -1 -1 -1 -1 -1 -1
-1 0 0 0 0 0 0 0 0 0
-1 0 0 0 0 0 0 0 0 0
-1 0 0 0 0 0 0 0 0 0
-1 0 0 0 0 0 0 0 0 0
-0 1 0 0 0 0 0 0 0 0
-0 0 1 0 0 0 0 0 0 0", ExpOutput:"3 8 1
-", Output:"3 8 1"
-*/
-#include <stdio.h>
-
-int good(
-    int a[20][20], int i, int j, int m, int n,
-    int d); // This is the prototype for good() which will check whether the
-            // square matrix of dimension d*d with a[i][j] as the top left
-            // element is an identity matrix,if yes,then it will return d else 0
-
-int good(int a[20][20], int i, int j, int m, int n, int d) {
-
-  int p, q, check = -1;
-
-  for (p = 0; p <= d; p++)
-
-    for (q = 0; q <= d; q++)
+is its sub-matrix and is identity. Since the dimension of the largest sub-matrix
+of the given matrix is 2, the goodness is 2.
 
-      if (!(((p == q) && (a[i + p][j + q] == 1)) ||
-            ((p != q) && (a[i + p][j + q] == 0)))) {
+Your task:
+Given a matrix, print its goodness value and the location of the top left corner
+of the largest  identity sub-matrix. For the example given above, goodness value
+is 2 and location of the top left corner of the identity sub-matrix is (1,3)
+i.e. first row third column. If goodness is 0, then top left corner location may
+be taken as (-1,-1) since it is actually not defined.
+
+
+Assume all numbers to be integer. If their are two or more largest identity
+sub-matrix with the location of top-left corner at (i1,j1) and (i2,j2), then
+output (i1,j1) if (i1 < i2) or (i1 == i2 and j1 < j2) , otherwise output
+(i2,j2).
+
+Input:
+m,n //denoting the number of rows and columns of the input matrix
+followed by m x n matrix with m rows (each in a new line) and n columns
+e.g.
 
-        check = 0;
-        return 0;
-        break;
-      }
+3 4
+0 1 1 0
+1 0 0 1
+1 0 2 3
 
-  if (check == -1)
+Output:
+g i j // if g is your goodness value and (i,j) is the location of the top left
+corner of the identity sub-matrix.
 
-    return d + 1;
-}
+e.g. answer for the above input will be
 
+2 1 3
+*/
+#include <stdio.h>
+int min(int a, int b) { return (a < b) ? a : b; }
 int main() {
+  int m, n, i, j, k, l, ans_i = -1, ans_j = -1, flag;
+  int max_goodness = 0, curr_goodness, max_gp;
+  scanf("%d%d", &m, &n);
+
+  int M[m][n];
+
+  for (i = 0; i < m; i++) {
+    for (j = 0; j < n; j++) {
+      scanf("%d", &M[i][j]);
+    }
+  }
 
-  int a[20][20], m, n, i, j, d, g = 0, l, i1, j1;
-
-  scanf("%d %d", &m, &n);
-
-  for (i = 0; i < m; i++)
-
-    for (j = 0; j < n; j++)
-
-      scanf("%d ", &a[i][j]);
-
-  for (i = 0; i < m - 1; i++)
-
-    for (j = 0; j < n - 1; j++) {
-
-      if (a[i][j] == 1) { // good will be called only when a[i][j]=1
-
-        for (l = 0; (i + l) < m && (j + l) < n; l++) {
-
-          d = good(a, i, j, m, n, l);
-
-          if (d != 0) {
-
-            if (d > g) {
-
-              g = d;
-              i1 = i;
-              j1 = j;
-
+  for (i = 0; i < m; i++) {
+    for (j = 0; j < n; j++) {
+      // checking whether an identity sub matrix begin at (i,j) i.e. at i+1th
+      // row and j+1th column
+      curr_goodness = 0;
+      flag = 0;
+      max_gp = min(m - i, n - j);
+      for (k = 0; k < max_gp; k++) {
+        for (l = k; l >= 0; l--) {
+          if (l == 0) {
+            if (M[i + k][j + k] != 1) {
+              curr_goodness = k;
+              flag = 1;
+              break;
             }
 
-            else if (g == d) {
-
-              if ((i < i1) || ((i == i1) && (j < j1)))
-                i1 = i;
-              j1 = j;
+          } else {
+            if (M[i + k][j + k - l] != 0 || M[i + k - l][j + k] != 0) {
+              curr_goodness = k;
+              flag = 1;
+              break;
             }
           }
         }
+        if (flag == 1)
+          break;
       }
-    }
-
-  if (g == 0) {
 
-    printf("%d %d %d", g, -1, -1);
-
-  }
+      if (k == max_gp)
+        curr_goodness = max_gp;
 
-  else {
-
-    printf("%d %d %d", g, i1 + 1, j1 + 1);
+      if (curr_goodness > max_goodness) {
+        max_goodness = curr_goodness;
+        ans_i = i + 1;
+        ans_j = j + 1;
+        // printf("%d %d %d\n",ans_i,ans_j,max_goodness );
+      }
+    }
   }
-
-  return 0;
+  printf("%d %d %d\n", max_goodness, ans_i, ans_j);
 }
\ No newline at end of file
